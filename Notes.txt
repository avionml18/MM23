// Use graphs which has vertices and edges to make your maze-solving algorithm
is_dest square weird

1/25/24

* Once you enter the destination square, you can populate the surrounding walls automatically for you since there's only,
one entrance into the destination "big" square.

* Maybe a way to guarantee getting out of the destination squares at the beginning of return-to-start mode
    * tell it to go to the nearest explored square (the only one nearest is the one that got it into the destination square)
    and then put an invisible wall to block off the entrance to the destination square

* Having repeated intersections in the intersection list may be a problem or less efficient. It means you figured out a way,
to get back to wherever you wanted to backtrack. That technically means the most recent intersection should be the only one
in the intersection list. [(8,7), (8,8), (7,8), (7,7), (8,7)] -> you would want the last one (and it's the bot exploring,
the destination squares).

Explanation of comments in a program
# 1. Recheck intersection list that recent "intersections" are actual intersection
    When adding intersection, it is a potential intersection since it's most likely an iteration of checking one wall
    to be an actual wall while the others haven't been checked. Thus, the coordinate added to the intersection
    list is simply temporary until it's verified. However, checking every wall would be too long, especially for DPS
    algorithm.
        PROPOSED SOLUTION 1: Check after every iteration of the loop for any potential intersections to not be ones by
        checking the number of walls a square has. (Always two ways to check if there's an intersection: number of
        walls and number of directions)
        PROPOSED SOLUTION 2: ?


List compresion can filter results thorugh a list and provide a new one for you

opposite directions shouldn't happen in the intersection list

